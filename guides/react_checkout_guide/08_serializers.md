### Serializers

Let's move to our backend to continue this functionality

We want to add a gem called Active Model Serializer

So what is a serializer? A serializer makes sure that our JSON responses has particular shape and content, rather than the content provided by the built-in JSON responses. We want to be in control of the information that is leaving the application, and to do that we are using this gem.

Add the gem to your `Gemfile` and run bundle

```rb
gem 'active_model_serializers'
```

Create the file a configuration file where we are adding the settings.

```bash
$ touch config/initializers/active_model_serializers.rb
```

Add

```rb
ActiveModelSerializers.config.adapter = :json
```

Now let's generate a new serializer. 
In the future a new serializer will be generated by default if you generate a new model. 
But for our existing model, we will run the generator.


```bash
$ rails g serializer order
```

This generator creates a new file. But before we add code to this (and there is a lot of code to add) we need to refactor our test and implementation to match the serialization.
Go over the following code carefully and take note of the changes we are making.

`spec/requests/api/client_can_create_new_order_spec.rb`

```rb
RSpec.describe Api::OrdersController, type: :request do
  let!(:product_1) { create(:product, name: "Pizza", price: 10) }
  let!(:product_2) { create(:product, name: "Kebab", price: 20) }

  before do
    post "/api/orders", params: { product_id: product_1.id }
    order_id = JSON.parse(response.body)["order"]["id"]
    @order = Order.find(order_id)
  end

  describe "POST /api/orders" do
    it "responds with success message" do
      expect(JSON.parse(response.body)["message"]).to eq "The product has been added to your order"
    end

    it "responds with order id" do
      expect(JSON.parse(response.body)["order"]["id"]).to eq @order.id
    end

    it "responds with right amount of products" do
      expect(JSON.parse(response.body)["order"]["products"].count).to eq 1
    end

    it "responds with right order total" do
      expect(JSON.parse(response.body)["order"]["total"]).to eq 10
    end
  end

  describe "PUT /api/orders/:id" do
    before do
      put "/api/orders/#{@order.id}", params: { product_id: product_2.id }
      put "/api/orders/#{@order.id}", params: { product_id: product_2.id }
    end

    it "adds another product to order if request is a PUT and param id of the order is present" do
      expect(@order.order_items.count).to eq 3
    end

    it "responds with order id" do
      expect(JSON.parse(response.body)["order"]["id"]).to eq @order.id
    end

    it "responds with right amount of unique products" do
      expect(JSON.parse(response.body)["order"]["products"].count).to eq 2
    end

    it "responds with right order total" do
      expect(JSON.parse(response.body)["order"]["total"]).to eq 50
    end
  end
end
```

And now for the serializer. Go over the code here carefully and try to understand what is happening. I advise you to use binding.pry to stop the execution of the code and dive deeper into hoe these different methods work together. 

`app/serializers/order_serializer.rb`

```rb
class OrderSerializer < ActiveModel::Serializer
  attributes :id, :products_1, :products_2, :products_3, :products, :total, :order_total

  def products_1
    products = []
    object.order_items.group_by(&:product_id).each do |key, value|
      product = Product.find(key)
      hash = { amount: value.count, name: product.name, total: (product.price * value.count) }
      products.push hash
    end
    products
  end

  def products_2
    products = []
    unique_items = object.order_items.uniq(&:product)
    unique_items_count = object.order_items.group_by(&:product_id).map { |key, value| [key, value.size] }.to_h
    unique_items.each do |item|
      products.push(
        amount: unique_items_count[item.product_id],
        name: item.product.name,
        total: (unique_items_count[item.product_id] * item.product.price)
      )
    end
    products
  end

  def products_3
    object.order_items.group_by(&:product_id).map do |_key, value|
      product = value.uniq(&:product_id)[0].product
      { amount: value.size, name: product.name, total: (value.size * product.price) }
    end
	end
	alias_method :products, :products_3

  def total
    object.order_items.joins(:product).sum('products.price')
  end
end
```

And  we need to update our controller with the changes.

`app/controllers/api/orders_controller.rb`

```rb
class Api::OrdersController < ApplicationController
  def create
    order = Order.create
    order.order_items.create(product_id: params[:product_id])
    render json: create_json_response(order)
  end

  def update
    order = Order.find(params[:id])
    product = Product.find(params[:product_id])
    order.order_items.create(product: product)
    render json: create_json_response(order)
  end

private

  def create_json_response(order)
    json = { order: OrderSerializer.new(order) }
    json.merge!(message: 'The product has been added to your order')
  end
end
```

And finally add this the method to order model.
```rb
def order_total
  order_items.joins(:product).sum("products.price")
end
```

Run your tests